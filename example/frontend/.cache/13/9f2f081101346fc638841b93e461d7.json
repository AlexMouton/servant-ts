{"id":"../node_modules/rxjs/operator/share.js","dependencies":[{"name":"/Users/stevenmaccoun/projects/servant-ts/example/frontend/node_modules/rxjs/operator/share.js.map","includedInParent":true,"mtime":1544898207315},{"name":"/Users/stevenmaccoun/projects/servant-ts/example/frontend/package.json","includedInParent":true,"mtime":1545675554786},{"name":"/Users/stevenmaccoun/projects/servant-ts/example/frontend/.babelrc","includedInParent":true,"mtime":1545599562417},{"name":"/Users/stevenmaccoun/projects/servant-ts/example/frontend/node_modules/rxjs/package.json","includedInParent":true,"mtime":1544898207315},{"name":"../operators/share","loc":{"line":2,"column":22},"parent":"/Users/stevenmaccoun/projects/servant-ts/example/frontend/node_modules/rxjs/operator/share.js","resolved":"/Users/stevenmaccoun/projects/servant-ts/example/frontend/node_modules/rxjs/operators/share.js"}],"generated":{"js":"\"use strict\";\nvar share_1 = require('../operators/share');\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n *\n * This behaves similarly to .publish().refCount(), with a behavior difference when the source observable emits complete.\n * .publish().refCount() will not resubscribe to the original source, however .share() will resubscribe to the original source.\n * Observable.of(\"test\").publish().refCount() will not re-emit \"test\" on new subscriptions, Observable.of(\"test\").share() will\n * re-emit \"test\" to new subscriptions.\n *\n * <img src=\"./img/share.png\" width=\"100%\">\n *\n * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n * @method share\n * @owner Observable\n */\nfunction share() {\n    return share_1.share()(this);\n}\nexports.share = share;\n;\n","map":{"version":3,"file":"share.js","sourceRoot":"","sources":["../../src/operator/share.ts"],"names":[],"mappings":";AACA,sBAAqC,oBAAoB,CAAC,CAAA;AAE1D;;;;;;;;;;;;;;;GAeG;AACH;IACE,MAAM,CAAC,aAAW,EAAE,CAAC,IAAI,CAAkB,CAAC;AAC9C,CAAC;AAFe,aAAK,QAEpB,CAAA;AAAA,CAAC","sourcesContent":["import { Observable } from '../Observable';\nimport { share as higherOrder } from '../operators/share';\n\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n *\n * This behaves similarly to .publish().refCount(), with a behavior difference when the source observable emits complete.\n * .publish().refCount() will not resubscribe to the original source, however .share() will resubscribe to the original source.\n * Observable.of(\"test\").publish().refCount() will not re-emit \"test\" on new subscriptions, Observable.of(\"test\").share() will\n * re-emit \"test\" to new subscriptions.\n *\n * <img src=\"./img/share.png\" width=\"100%\">\n *\n * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n * @method share\n * @owner Observable\n */\nexport function share<T>(this: Observable<T>): Observable<T> {\n  return higherOrder()(this) as Observable<T>;\n};\n"]}},"hash":"0eaf79efb0763940fcfd57bd4dc5b88f","cacheData":{"env":{}}}